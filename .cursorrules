# Repository Overview

This is a monorepo of **Framer code components** — reusable React 18 compatible TSX components that work seamlessly in the Framer canvas, preview, and published sites.

---

## Code Standards

All code must be maintainable for a large open-source community and meet Google-level engineering standards:

- **Clarity over cleverness** — write self-documenting code with clear naming and structure
- **Strong typing** — leverage TypeScript fully; avoid `any` when possible
- **Self-contained** — components must work without external dependencies (beyond allowed libraries)
- **Accessibility first** — semantic HTML, ARIA labels, keyboard navigation, focus management
- **Canvas-safe** — guard browser APIs and heavy effects; use `useIsStaticRenderer()` for animated components
- **Well-understood comments** — explain the "why" in comments, not just the "what"

---

## What is Framer and How to Build Code Components

### Overview
Framer is a design tool where designers build production websites. Code components are React/TSX components that designers can drag onto the canvas and configure through visual controls—no code editing required.

### Core Requirements

**JSDoc layout annotations** (always required on component export):
- `@framerIntrinsicWidth` and `@framerIntrinsicHeight` — initial size when dropped on canvas
- `@framerSupportedLayoutWidth` and `@framerSupportedLayoutHeight` — choose from: `auto`, `fixed`, `any`, `any-prefer-fixed`
  - `auto` — Component dictates its own size based on content
  - `fixed` — Component fills 100% of a fixed-size container
  - `any` — Users can toggle between auto and fixed (default)
  - `any-prefer-fixed` — Same as `any`, but defaults to fixed

**Root element contract:**
- Spread `props.style` onto the root (enables Framer to control sizing)
- Use `position: "relative"`, `width: "100%"`, `height: "100%"`
- Avoid `position: fixed` on root (use portals if needed)

**Property controls:**
- Use both `defaultValue` in `addPropertyControls()` AND `defaultProps` on your component
- Property controls only affect canvas; `defaultProps` are for development and non-canvas usage
- Available control types: `Boolean`, `String`, `Number`, `Color`, `Enum`, `ResponsiveImage`, `Font`, `Padding`, `BorderRadius`, `BoxShadow`, `Date`, `File`, `ComponentInstance`, `EventHandler`, `Transition`, `Link`, `Array`, `Object`, `Border`

### Allowed Libraries (self-contained only)
- `react` — React core
- `react-dom` — DOM utilities (e.g., `createPortal`)
- `framer` — Framer APIs (`addPropertyControls`, `ControlType`, `RenderTarget`, `useIsStaticRenderer`, `useLocaleInfo`)
- `framer-motion` — Animation library

**No other imports allowed** (no UI kits, icon libraries, HTTP clients, state managers, etc.)

### Environment Detection & Safety

**Multiple render contexts:**
- `RenderTarget.canvas` — Framer's design editor
- `RenderTarget.preview` — Live preview or published site
- `RenderTarget.export` — Export canvas
- `RenderTarget.thumbnail` — Project thumbnails

**For animated components (WebGL, heavy animations):**
- Use `useIsStaticRenderer()` — ensures component is static on BOTH Canvas AND Export
- Prevents performance issues and export problems like unwanted tiling

**For general environment detection:**
- Use `RenderTarget.current()` to check which context you're in

**Guard browser APIs:**
- Never access `window`, `document`, or `navigator` during render
- Always wrap browser API calls inside `useEffect` (runs only client-side)
- Use `typeof window !== "undefined"` checks before accessing browser APIs

### Common Pitfalls

**Most common error — useEffect returning non-function values:**
- Arrow functions without curly braces unintentionally return values and cause crashes
- Always wrap function bodies in curly braces

**Server-side rendering issues:**
- Never access browser APIs during render (causes optimization failures)
- Use CSS media queries instead of `window.innerWidth` for responsive behavior
- Move all browser API calls inside `useEffect`

**Performance optimization:**
- Use `useMemo` and `useCallback` to prevent unnecessary re-renders
- Use CSS transforms (`translateX`, `scale`) instead of position changes for animations
- Only use code components when native Framer layers can't achieve the same result
- Consolidate multiple event listeners using event delegation

**Dynamic auto-sizing:**
- Use `useLayoutEffect` (not `useEffect`) for auto-sizing based on state changes
- Framer's measuring system works best with `useLayoutEffect`

**Measuring component size:**
- Use `useMeasuredSize` from `https://framer.com/m/framer/useMeasuredSize.js`
- Warning: impacts performance, use sparingly

### Additional Features

**Localization:**
- Use `useLocaleInfo()` to access and set locale information

**Event Handlers:**
- Use `ControlType.EventHandler` to expose events in Smart Components for prototyping interactions

**Error Handling:**
- Code Boundaries (since March 2025) automatically isolate component errors
- Components that error are hidden instead of crashing the entire site
- Overrides with errors are disabled and the original frame renders

### Troubleshooting

**Finding broken components:**
- Check browser console for `code-crash` identifier
- Paste identifier into Quick Actions (CMD+K / CTRL+K) to locate the component

**Optimization errors:**
- If component fails during site optimization, it will retry on page load
- Common cause: accessing browser APIs during server-side rendering
- Solution: Move browser API calls into `useEffect` or use placeholders

### Resources
- [Code Components Introduction](https://www.framer.com/developers/components-introduction)
- [Property Controls](https://www.framer.com/developers/property-controls)
- [API Reference](https://www.framer.com/developers/components-reference)
- [Auto-Sizing](https://www.framer.com/developers/auto-sizing)
- [Framer Motion](https://motion.dev/docs/framer)
